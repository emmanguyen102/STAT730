###McMC methods: Gibbs, M-H in R

##Gibbs sampling

## Example 1: 

## True joint probability distribution for theta1
## and theta2
joint <- matrix(c(.1,.2,.2,.1,.3,.1),2,3)
joint

## Gibbs sampler generating samples from 2 full
## conditional distributions
gibbs1 <- function(niter, th10, th20){
  th1 <- th10
  th2 <- th20
  
  th1_sam <- NULL  # to store samples for theta1
  th2_sam <- NULL  # to store samples for theta2
  
  myjoint <- matrix(0, nrow=2, ncol =3)
  for (i in 1:niter){
    th1 <- sample(c(1,2), 1, prob=joint[,th2]/sum(joint[,th2]))
    th2 <- sample(c(1,2,3), 1, prob=joint[th1,]/sum(joint[th1,]))
    
    th1_sam <- append(th1_sam, th1) #collect samples for theta1
    th2_sam <- append(th2_sam, th2) #collect samples for theta2
    
    myjoint[th1,th2] <- myjoint[th1,th2] +1
  }
  print(myjoint/sum(myjoint)) #joint prob distribution constructed from our samples
  list(th1=th1_sam, th2=th2_sam)
}

eg1 <- gibbs1(1000,1,1)
eg2 <- gibbs1(10000,1,1)


## Example 2: Gibbs sampling for bivariate Normal 
## random variables

## Let X~Normal(mu,V) where

V <- matrix(c(1,1,1,4),2,2) #covariance matrix
mu <- c(0,0) #mean vector

## Samples from X can be generated by the following
## gibbs sampler using the full conditional distributions
## x1|x2 and x2|x1

gibbs2 <- function(niter, x10,x20, V, mu){
  x1 <- x10
  x2 <- x20
  
  x1.samp <- NULL
  x2.samp <- NULL
  
  sig1 <- sqrt(V[1,1])
  sig2 <- sqrt(V[2,2])
  
  rho <- V[1,2]/(sig1*sig2) #correlation coefficient
  
  sig12 <- sig1*sqrt(1-rho^2)
  sig21 <- sig2*sqrt(1-rho^2)
  
  for (i in niter){
    x1 <- rnorm(1, mu[1] + sig1/sig2*rho*(x2-mu[2]), sig12 )     # conditional distn x1|x2
    x2 <- rnorm(1, mu[2] + sig2/sig1*rho*(x1-mu[1]), sig21 )    # conditional distn x2|x1
    
    x1.samp <- append(x1.samp, x1)
    x2.samp <- append(x2.samp, x2)
  }
  
  list( x1=x1.samp, x2=x2.samp)  # results collected
}

n.gib <- gibbs2(10000, 0,0, V,mu)




## Example 3: Metropolis-Hastings sampling

# Specify the (log- transformed)  target posterior distribution as a function

logpost <- function(x,y){
  - (a*x^2+ 2*b*x*y+ c*y^2)
}

# Set values required

a<- 5.25
c<- 5.25
b <- - 5.24

# M-H  for drawing samples from the above logpost

mh.1 <- function( niter, dx, dy, x0, y0) {
  
  xsamp <- NULL
  ysamp <- NULL
  
  x<- x0    # initial values
  y <- y0
  
  accept <-0
  
  for (i in 1:niter){
    
    xstar <- x+ runif(1, -dx, dx)   # Proposal moves a random distance +/-
    ystar <- y+ runif(1, -dy, dy)
    
    logalpha <- logpost(xstar, ystar)-logpost(x,y)
    
    if ( log( runif(1,0,1) ) < logalpha){
      x <- xstar
      y <- ystar
      accept <- accept +1
    } # end of if
    
    xsamp <- append(xsamp, x)
    ysamp <- append(ysamp, y)
    
  } # end of for
  
  ac <- accept/niter     # acceptance rate
  
  list( xs=xsamp, ys=ysamp, ac=ac)
}

eg.n <- mh.1(10000, 2,2,0,0)
eg.n <- mh.1(10000, 1,1,0,0)

hist(eg.n$xs, 100, prob=T)
hist(eg.n$ys, 100, prob=T)

plot(eg.n$xs, eg.n$ys)


##Example 4: Normal data with Normal conjugate prior

# setting values
tau<-1
sig2<-10
mu0<-5;
n<-5

# (TRUE) mean of the normal posterior
mu.n<-( mean(y)*n/tau + mu0/sig2 )/( n/tau+1/sig2)   # [1] 10.02745
# (TRUE) variance of the normal posterior
sig2.n<-1/(n/tau+1/sig2)      # [1] 0.1960784

# defining the data
x<-c(9.37, 10.18, 9.16, 11.60, 10.33)


#### Metropolis Algorithm ####

## M = total num of simulations
theta<-0 ; delta<-2 ; M<-10000 ; THETA<-NULL
set.seed(1)

for(s in 1:M)
{
  ## simulating our proposal
  theta.star<-rnorm(1,theta,sqrt(delta))
  
  ##taking the log of the ratio alpha
  log.alpha<-( sum(dnorm(x,theta.star,sqrt(tau),log=TRUE)) + dnorm(theta.star,mu0,sqrt(sig2),log=TRUE) ) -
    ( sum(dnorm(x,theta,sqrt(tau),log=TRUE)) + dnorm(theta,mu0,sqrt(sig2),log=TRUE) )
  
  if(log(runif(1))<log.alpha) { theta<-theta.star }
  
  ##updating THETA
  THETA<-c(THETA,theta)
}

plot(THETA[1:100])
plot(THETA, type='l')
hist(THETA[1000:10000], prob=T)

th=seq(8.5,11.5, length=100)
lines(th, dnorm(th, 10.03,sqrt(0.20)))


